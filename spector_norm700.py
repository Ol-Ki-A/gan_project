# -*- coding: utf-8 -*-
"""spector_norm700.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kbreVlpKx08dRX1YhuvuSPIvggpxc0zW
"""

import torch
import torchvision
from torchvision import transforms
import matplotlib.pyplot as plt
import numpy as np
import torch.nn as nn
import torch.nn.functional as F
from torchvision import models
import torch.optim as optim
from torch.utils.data import Dataset
from torchvision import datasets
from torchvision.transforms import ToTensor
from tqdm.notebook import tqdm
import os
from torch.utils.data import DataLoader
from torchvision.datasets import ImageFolder
import torchvision.transforms as tt
import cv2
from torchvision.utils import save_image
from torchvision.utils import make_grid
import seaborn as sns

training_data = torchvision.datasets.MNIST(
    root='./data',
    train=True,
    download=True,
    transform=transforms.Compose ([ 
        transforms.ToTensor () 
        ])
)

test_data = torchvision.datasets.MNIST(
    root='./data',
    train=False,
    download=True,
    transform=transforms.Compose ([ 
        transforms.ToTensor () 
        ])
)

batch_size = 100

batch_size_test = 100

train_loader = torch.utils.data.DataLoader(training_data, batch_size= batch_size, shuffle=True, num_workers=2)

test_loader = torch.utils.data.DataLoader(test_data, batch_size= batch_size_test, shuffle=False, num_workers=2)

from torch.nn.utils import spectral_norm

from torch.nn.utils import weight_norm

discriminator = nn.Sequential(
    #  1 x 28 x 28
    spectral_norm(nn.Linear(784, 1024)),
    #nn.BatchNorm1d(1024),
    #nn.Dropout(p=0.3),
    nn.LeakyReLU(0.2, inplace=True),
    spectral_norm(nn.Linear(1024, 512)),
    #nn.Dropout(p=0.5),
    #nn.BatchNorm1d(512),
    nn.LeakyReLU(0.2, inplace=True),
    spectral_norm(nn.Linear(512, 256)),
    #nn.Dropout(p=0.3),
    #nn.BatchNorm1d(256),
    nn.LeakyReLU(0.2, inplace=True),
    spectral_norm(nn.Linear(256, 1)),
    nn.Flatten(),
    nn.Sigmoid())

latent_size = 100
generator = nn.Sequential(       
        (nn.Linear(latent_size, 256)),
        nn.BatchNorm1d(256),
        nn.LeakyReLU(0.2, inplace=True),
        (nn.Linear(256, 512)),
        nn.BatchNorm1d(512),
        nn.LeakyReLU(0.2, inplace=True),
        (nn.Linear(512, 1024)),
        nn.BatchNorm1d(1024),
        nn.LeakyReLU(0.2, inplace=True),
        (nn.Linear(1024, 784)),
        nn.BatchNorm1d(784),
        nn.Tanh()
)

opt1 = torch.optim.Adam(discriminator.parameters(), lr=1e-4)

opt2 = torch.optim.Adam(generator.parameters(), lr=1e-4)

BCE_loss1 = torch.nn.BCELoss()
BCE_loss2 = torch.nn.BCELoss()

device = torch.device("cuda")

discriminator.to(device)
generator.to(device)

real_score = []
fake_score = []
epochs = 790
losses_g = []
losses_d = []
for epoch in range(epochs):
  loss_d_tmp = []
  loss_g_tmp = []
  real_score_tmp = []
  fake_score_tmp = []
  for real_image, i in tqdm(train_loader):
    opt1.zero_grad()
    real_image = real_image.to(device)
    real_image = real_image.view(-1, 784)
    real_preds = discriminator(real_image)
    #присвоим реальному изображению метку класса 1
    real_targets = torch.ones(real_image.size(0), 1, device=device) 
    #учим дисриминатор предсказывать эту метку класса
    real_loss = BCE_loss1(real_preds, real_targets)
    #берем латентный вектор
    latent = torch.randn(batch_size, latent_size, device=device)
    #генерируем изображение
    fake_image = generator(latent)
    #присваимваем метку класса 0
    fake_targets = torch.zeros(fake_image.size(0), 1, device=device)
    #подвем в дискриминатор, считаем лосс
    fake_preds = discriminator(fake_image)
    fake_loss = BCE_loss2(fake_preds, fake_targets)
    #считаем скор и делаем шаг
    real_score_tmp.append(torch.mean(real_preds).item())
    fake_score_tmp.append(torch.mean(fake_preds).item())
    loss_d = real_loss + fake_loss
    loss_d.backward()
    opt1.step()
    loss_d_tmp.append(loss_d.item())
    #обучим генератор
    opt2.zero_grad()
        
    #генерируем изображение
    latent = torch.randn(batch_size, latent_size, device=device)
    fake_image = generator(latent)
        
    #подаем изображение дискриминатору 
    preds = discriminator(fake_image)
    targets = torch.ones(batch_size, 1, device=device)
    #считаем лосс генератора 
    loss_g = BCE_loss2(preds, targets)
    # делаем шаг
    loss_g.backward()
    opt2.step()
    loss_g_tmp.append(loss_g.item())
  if (epoch % 5 == 0):  
    torch.save(generator, "model_gen" + str(epoch) + ".zip")
    torch.save(discriminator, "model_dis" + str(epoch) + ".zip")
  print(f'loss generator on {epoch} = {np.mean(loss_g_tmp)}')
  print(f'loss discriminator on {epoch} = {np.mean(loss_d_tmp)}')
  print(f'real scores on {epoch} = {np.mean(real_score_tmp)}')
  print(f'fake scores on {epoch} = {np.mean(fake_score_tmp)}')
  losses_g.append(np.mean(loss_g_tmp))
  losses_d.append(np.mean(loss_d_tmp))
  real_score.append(np.mean(real_score_tmp))
  fake_score.append(np.mean(fake_score_tmp))

discriminator = torch.load("model_dis395.zip")
generator = torch.load("model_gen395.zip")

#310
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#310
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#310
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#310
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#310
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#335
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#345
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#145
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#95
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#95
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#95
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#300
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#300
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#300
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

#300
image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

plt.figure(figsize=(15, 6))
plt.plot(losses_d, '-')
plt.plot(losses_g, '-')
plt.xlabel('epoch')
plt.ylabel('loss')
plt.legend(['Discriminator', 'Generator'])
plt.title('Losses');

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

plt.figure(figsize=(15, 6))
plt.plot(losses_d, '-')
plt.plot(losses_g, '-')
plt.xlabel('epoch')
plt.ylabel('loss')
plt.legend(['Discriminator', 'Generator'])
plt.title('Losses');

plt.figure(figsize=(15, 6))

plt.plot(real_score, '-')
plt.plot(fake_score, '-')
plt.xlabel('epoch')
plt.ylabel('score')
plt.legend(['Real', 'Fake'])
plt.title('Scores');

discriminator = torch.load("model_dis130.zip")
generator = torch.load("model_gen130.zip")

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

discriminator = torch.load("model_dis110.zip")
generator = torch.load("model_gen110.zip")

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

discriminator = torch.load("model_dis170.zip")
generator = torch.load("model_gen170.zip")

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

discriminator = torch.load("model_dis95.zip")
generator = torch.load("model_gen95.zip")

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

discriminator = torch.load("model_dis90.zip")
generator = torch.load("model_gen90.zip")

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

image = []
for i in range(64):
  latent = torch.randn(batch_size, latent_size, device=device)
  fake_image = generator(latent)
  fake_image = fake_image.view(fake_image.size(0), 1, 28, 28)
  #fake_image = fake_image.cpu().detach().numpy() 
  image.append(fake_image[0].cpu())
#image = torch.FloatTensor(image) 
print(fake_image.shape)
fig, ax = plt.subplots(figsize=(8, 8))
ax.set_xticks([]); ax.set_yticks([])
ax.imshow(make_grid(image, nrow=8).permute(1, 2, 0))

discriminator = torch.load("model_dis200.zip")
generator = torch.load("model_gen200.zip")

